from transformers import AutoModelForCausalLM, AutoTokenizer
import requests
import pandas as pd
import numpy as np
import time
import xgboost as xgb
import torch
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error
import google.generativeai as genai

# 🔑 Set up Gemini API key
genai.configure(api_key="AIzaSyAuSce1nyreQQtLOl61a_Mfo0eWlej62HU")

# 🔥 Load Gemini Model
gemini_model = genai.GenerativeModel("gemini-2.0-flash")


available_models = [m.name for m in genai.list_models()]
print("Available models:", available_models)

if "models/gemini-2.0-flash" not in available_models:
    raise ValueError("❌ 'gemini-2.0-flash' model is not available. Check API key or plan.")

    
# 🌍 NASA Exoplanet Archive API
NASA_ARCHIVE_URL = (
    "https://exoplanetarchive.ipac.caltech.edu/TAP/sync?"
    "query=select+pl_name,pl_rade,pl_bmasse,pl_orbper,pl_eqt,st_teff,st_mass,st_rad,st_met+from+pscomppars&format=json"
)

def fetch_data(url, retries=3, delay=5):
    for attempt in range(retries):
        try:
            print(f"[Attempt {attempt + 1}] Fetching data from NASA API...")
            response = requests.get(url, timeout=20)
            response.raise_for_status()
            data = response.json()
            if isinstance(data, list) and data:
                return data
        except requests.exceptions.RequestException as e:
            print(f"[Error] Request failed: {e}")
        time.sleep(delay)
    return []

nasa_data = fetch_data(NASA_ARCHIVE_URL)
df = pd.DataFrame(nasa_data)
if df.empty:
    raise ValueError("[Fatal] NASA data fetch failed. Cannot proceed.")

numeric_columns = ['pl_rade', 'pl_bmasse', 'pl_orbper', 'pl_eqt', 'st_teff', 'st_mass', 'st_rad', 'st_met']
df[numeric_columns] = df[numeric_columns].apply(pd.to_numeric, errors='coerce')
df.dropna(subset=numeric_columns, inplace=True)


# ⚙️ Additional Factors Calculations
def atmospheric_composition_score(row):
    return max(0, min(20, (row['st_met'] + 0.5) * 15))

def liquid_water_probability(row):
    return max(0, min(30, (300 - abs(row['pl_eqt'] - 300)) / 3)) if 200 <= row['pl_eqt'] <= 400 else 0

def magnetosphere_strength(row):
    return max(0, min(25, (row['st_mass'] / row['pl_bmasse']) * 10))

def stellar_radiation_factor(row):
    return max(0, min(25, (6000 - row['st_teff']) / 100)) if row['st_teff'] < 6000 else 0
    

def rule_based_score(row):
    if row['pl_rade'] > 3:
        return 0
    mass_component = min(20, row['pl_bmasse'] * 5)  
    temp_component = max(0, (300 - abs(row['pl_eqt'] - 300)) / 3) if 200 <= row['pl_eqt'] <= 400 else 0
    return min(100, mass_component + temp_component)

df['habitability_score'] = df.apply(rule_based_score, axis=1)

def terraformability_score(row):
    if row['pl_eqt'] < 200 or row['pl_eqt'] > 400:
        return 0
    atmosphere_factor = max(0, min(30, (row['st_met'] + 0.5) * 20))
    gravity_factor = max(0, min(30, 9.8 / (row['pl_bmasse'] ** 0.5)))
    temp_factor = max(0, (300 - abs(row['pl_eqt'] - 300)) / 3)
    return min(100, atmosphere_factor + gravity_factor + temp_factor)

df['terraformability_score'] = df.apply(terraformability_score, axis=1)

X, y = df[numeric_columns], df['habitability_score']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

xgb_model = xgb.XGBRegressor(n_estimators=300, learning_rate=0.05, max_depth=7)
xgb_model.fit(X_train, y_train)

y_pred = xgb_model.predict(X_test)
mae = mean_absolute_error(y_test, y_pred)
print(f"\n✅ Model trained successfully! MAE: {mae:.4f}\n")

def generate_reasoning(planet_data, habitability, terraformability):
    prompt = f"""
    You are an AI astrophysicist analyzing exoplanet habitability and terraformability using NASA, ESA, and TESS data. Your goal is to explain in-depth whether {planet_data['pl_name']} is habitable and if it can be terraformed. 

    ### 🔬 Exoplanet Details:
    - **Mass**: {planet_data['pl_bmasse']} Earth masses
    - **Radius**: {planet_data['pl_rade']} Earth radii
    - **Temperature**: {planet_data['pl_eqt']} K
    - **Orbital Period**: {planet_data['pl_orbper']} days
    - **Host Star Temperature**: {planet_data['st_teff']} K
    - **Stellar Mass**: {planet_data['st_mass']} Solar masses
    - **Metallicity**: {planet_data['st_met']} [Fe/H]

    ### 🏞️ Habitability Score: {habitability}%
    This score is based on:
    - **Surface gravity & escape velocity**
    - **Atmospheric retention capability**
    - **Liquid water stability**
    - **Stellar radiation & magnetosphere protection**
    - **Presence in habitable zone**
    
    ### 🌍 Terraformability Score: {terraformability}%
    To make {planet_data['pl_name']} Earth-like, analyze:
    - **Atmospheric composition & pressure adjustments**
    - **Magnetosphere generation possibilities**
    - **Temperature regulation (Greenhouse Effect & Albedo Control)**
    - **Tidal locking effects on climate**
    
    #### 🔥 **Scientific Reasoning:**
    Explain in-depth whether {planet_data['pl_name']} can support life, using **planetary science, astrophysics, and geophysics**. Address how its **surface gravity, stellar radiation, and atmospheric loss rate** affect habitability.

    ### 🛠️ **Terraformability Solution:**
    Provide **scientific and engineering solutions** for transforming {planet_data['pl_name']} into a habitable planet:
    - **Technical Solutions:**
    - **Atmospheric Engineering:** Methods to introduce or remove specific gases (e.g., injecting greenhouse gases or using chemical reactions to modify CO₂ levels).
    - **Artificial Magnetosphere:** Strategies to generate a magnetic field (e.g., placing superconducting rings around the planet or using planetary-scale electromagnets).
    - **Climate Control Mechanisms:** Geoengineering techniques such as orbital mirrors, albedo modification, or controlled greenhouse gas release.
    - **Water Introduction Methods:** Methods to create or transport water (e.g., comet redirection, subsurface melting, or synthetic hydrocarbon lakes).
    - **Pressure & Gravity Adjustment:** Analysis of potential solutions like atmospheric thickening to compensate for low gravity effects.

    - **Non-Technical Solutions:**
    - **Human Adaptation Strategies:** Genetic modifications, artificial habitats, and bioengineering life to survive in extreme conditions.
    - **Long-Term Ecological Planning:** Sustainable colonization models, self-replicating biospheres, and ecosystem introduction.
    - **Interplanetary Governance & Ethics:** Policies for planetary protection, ethical considerations for modifying alien worlds.
    
    🚀 **Final Conclusion:**  
    Summarize whether {planet_data['pl_name']} is a promising candidate for future space missions.
    """
    
    response = gemini_model.generate_content(prompt)
    return response.text

def main():
    while True:
        user_input = input("\n🔍 Enter exoplanet name (or 'exit' to quit): ").strip().lower()
        if user_input == 'exit':
            print("\n🚀 Exiting program. Goodbye!\n")
            break

        planet_data = df[df['pl_name'].str.lower() == user_input]
        if planet_data.empty:
            print("\n❌ Planet not found. Try another name.\n")
            continue

        planet_data = planet_data.iloc[0]
        ml_score = xgb_model.predict(pd.DataFrame([planet_data[numeric_columns]]))[0]
        terraformability = terraformability_score(planet_data)

        print(f"\n🌍 **{planet_data['pl_name']} Analysis:**")
        print(f"📊 ML Habitability Prediction: {ml_score:.2f}%")
        print(f"📏 Rule-Based Habitability Score: {planet_data['habitability_score']}%")
        print(f"🌏 Terraformability Score: {terraformability}%")

        mass_component = min(20, planet_data['pl_bmasse'] * 5)
        temp_component = max(0, (300 - abs(planet_data['pl_eqt'] - 300)) / 3) if 200 <= planet_data['pl_eqt'] <= 400 else 0
        atmosphere_component = atmospheric_composition_score(planet_data)
        radiation_component = stellar_radiation_factor(planet_data)
        magnetosphere_component = magnetosphere_strength(planet_data)

        total_score = mass_component + temp_component + atmosphere_component + radiation_component + magnetosphere_component
        print(f"🪐 Mass Component: {mass_component / total_score * 100:.2f}%")
        print(f"🌡️ Temperature Component: {temp_component / total_score * 100:.2f}%")
        print(f"☁️ Atmospheric Composition: {atmosphere_component / total_score * 100:.2f}%")
        print(f"☀️ Stellar Radiation Factor: {radiation_component / total_score * 100:.2f}%")
        print(f"🧲 Magnetosphere Strength: {magnetosphere_component / total_score * 100:.2f}%")
        
        
        print("\n🧠 AI Reasoning:") 
        print(generate_reasoning(planet_data, ml_score, terraformability))
        print("=================================")

main()
